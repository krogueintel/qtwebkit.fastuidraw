Building:
  Tools/Scripts/build-webkit --qt --release --cmakeargs="-DENABLE_MINIBROWSER=ON"
  Tools/Scripts/build-webkit --qt --debug --cmakeargs="-DENABLE_MINIBROWSER=ON"

Qt WebKit: rendering.
  Entry point to drawing with QPainter is QWebFrameAdapter::renderRelativeCoords()
  in Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp. Full stack:

  QWebView::paint() --> QWebFrame::render() --> QWebFrameAdapter::renderRelativeCoords()

  Basic plan:
    1. WebCore infrastucture: namespaced functions to initialize FastUIDraw
       resources (atlases, caches) and OpenGL function setup for
       fastuidraw::gl::gl_binding. (done)
    2. Change QWebView to derived from QOpenGLWidget where QOpenGLContext
       of it is GL 4.5 core profile. (done)
    3. Construct fastuidraw::Painter in QWebView. (done and verified to
       draw).
    4. Modify QtTestBrowser to allow selecting FastUIDraw or QPainter to
       draw. (done for WebViewTraditional and additional stuff to prevent
       re-creation of FastUIDraw resources).
    5. Broad strokes:
       a. change PlatformGraphicsContext from QPainter to something that
          has both a fastuidraw::Painter and a QPainter. (done)
          i. A total of 32 files were touched:
             - 19 in WebCore
             -  7 in WebKit
             -  6 in WebKit2
          ii. The changes in WebKit2 we can ignore, since we are just
              doing the WebKit API; However, we need to also pay careful
              attention to GraphicsContext::isAccelerated() along with
              all the various Image classes in WebKit to make sure
              we render all content with one renderer or the other.
              How "accellerated 2d" (i.e. ACCELERATED_2D_CANVAS)
              interacts needs to be understood as well; that macro
              appears in (thankfully) only 19 files.
       b. text
         i. modify GlyphBuffer and/or TextRun to have a fastuidraw structs for text.
         ii. the actual drawing methods in a backend are located in FontCascade
         iii. Use (just created) FastUIDraw class fastuidraw::GlyphRun because
              WebKit works with ranges of text and does its own culling.
       c. GraphicsContext itself has state for how to stroke and filling
          where each has a color (WebCore::Color), gradient (WebCore::Gradient)
          and pattern (WebCore::Pattern); hopefully we can emulate Pattern
          with fastuidraw::PainterBrush. These classes have the methods
          to fill and draw that take a GraphicsContext. Also related,
          NativeImagePtr will need to change to a pointer that has
          a "something" that points to both a QPixmap and/or a
          fastuidraw::Image as well.
